flink的状态是保存在内存中的，如何防止内存不爆，分布式，每个slot有独立的内存  
并行度调整后，flink会把原先状态数据打乱重新均匀分配  
容错性，会持久化状态  

flink的状态分类：  
托管状态，由flink管理的，直接调flink接口  
原始状态，自定义的，自己管理  

状态内容：  
值状态ValueState  
列表状态ListState  
映射状态MapState  
聚合状态AggregateState  

状态只针对当前的并行子任务里面有效  
p97-p101 很啰嗦，没有实例，有点水，根据讲义讲的  

## 实例

五种不同状态编程StateTest，较好  
统计每个用户的pv，PeriodicPvExample，较好  
列表状态全外联结， TwoStreamJoinExample，例子不太好，水过  
统计整10秒窗口，各个url点击次数，FakeWindowExample 较好  
统计每个人过去5次访问的平均时间戳，AverageTimestampExample， 较好  

## DataStream算子为啥不能直接聚合，而要先keyBy呢

本质上是状态是按key保存的

## TTL

p108 讲得不好  

## 三种算子状态

p109 纯讲解，不好  
ListState、UnionListState、BroadcastState  

UnionListState： 效率低，一般不用  
BroadcastState： 希望每个子任务都有一份相同状态  

## 算子状态

p110、p111 和容错结合起来的算子状态
10条一次性输出，发生错误会从checkpoint中恢复  BufferingSinkExample  

## 广播状态

所有算子状态都一样
应用场景：动态配置、动态规则  

广播状态例子BehaviorPatternDetectExample， 实验做出来了，不理解，水过  